{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\nimport React, { createContext, useRef, useContext, useMemo, useEffect, useLayoutEffect, useDebugValue, forwardRef, createElement } from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { ThemeContext } from 'theming';\nexport { ThemeProvider, createTheming, useTheme, withTheme } from 'theming';\nimport isInBrowser from 'is-in-browser';\nimport warning from 'tiny-warning';\nimport { SheetsManager, create as create$1, getDynamicStyles, createGenerateId } from 'jss';\nexport { SheetsRegistry, createGenerateId } from 'jss';\nimport preset from 'jss-preset-default';\nimport { shallowEqualObjects } from 'shallow-equal';\nimport isPropValid from '@emotion/is-prop-valid';\nimport defaultCss from 'css-jss';\nvar getDisplayName = function getDisplayName(Component) {\n  return Component.displayName || Component.name || 'Component';\n};\nvar memoize = function memoize(fn) {\n  var lastArgs;\n  var lastResult;\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    if (Array.isArray(lastArgs) && args.length === lastArgs.length) {\n      var isSame = true;\n      for (var i = 0; i < args.length; i++) {\n        if (args[i] !== lastArgs[i]) {\n          isSame = false;\n        }\n      }\n      if (isSame) {\n        return lastResult;\n      }\n    }\n    lastArgs = args;\n    lastResult = fn.apply(void 0, args);\n    return lastResult;\n  };\n};\nvar mergeClasses = function mergeClasses(baseClasses, additionalClasses) {\n  var combinedClasses = _extends({}, baseClasses);\n  for (var name in additionalClasses) {\n    combinedClasses[name] = name in combinedClasses ? combinedClasses[name] + \" \" + additionalClasses[name] : additionalClasses[name];\n  }\n  return combinedClasses;\n};\n\n/**\n * Global index counter to preserve source order.\n * As we create the style sheet during componentWillMount lifecycle,\n * children are handled after the parents, so the order of style elements would\n * be parent->child. It is a problem though when a parent passes a className\n * which needs to override any childs styles. StyleSheet of the child has a higher\n * specificity, because of the source order.\n * So our solution is to render sheets them in the reverse order child->sheet, so\n * that parent has a higher specificity.\n *\n * We start at [Number.MIN_SAFE_INTEGER] to always insert sheets from react-jss first before any\n * sheet which might be inserted manually by the user.\n */\nvar index = Number.MIN_SAFE_INTEGER || -1e9;\nvar getSheetIndex = function getSheetIndex() {\n  return index++;\n};\nvar JssContext = createContext({\n  classNamePrefix: '',\n  disableStylesGeneration: false,\n  isSSR: !isInBrowser\n});\nvar defaultManagers = new Map();\nvar getManager = function getManager(context, managerId) {\n  // If `managers` map is present in the context, we use it in order to\n  // let JssProvider reset them when new response has to render server-side.\n  var managers = context.managers;\n  if (managers) {\n    if (!managers[managerId]) {\n      managers[managerId] = new SheetsManager();\n    }\n    return managers[managerId];\n  }\n  var manager = defaultManagers.get(managerId);\n  if (!manager) {\n    manager = new SheetsManager();\n    defaultManagers.set(managerId, manager);\n  }\n  return manager;\n};\nvar manageSheet = function manageSheet(options) {\n  var sheet = options.sheet,\n    context = options.context,\n    index = options.index,\n    theme = options.theme;\n  if (!sheet) {\n    return;\n  }\n  var manager = getManager(context, index);\n  manager.manage(theme);\n  if (context.registry) {\n    context.registry.add(sheet);\n  }\n};\nvar unmanageSheet = function unmanageSheet(options) {\n  if (!options.sheet) {\n    return;\n  }\n  var manager = getManager(options.context, options.index);\n  manager.unmanage(options.theme);\n};\nvar defaultJss = create$1(preset());\nvar sheetsMeta = new WeakMap();\nvar getMeta = function getMeta(sheet) {\n  return sheetsMeta.get(sheet);\n};\nvar addMeta = function addMeta(sheet, meta) {\n  sheetsMeta.set(sheet, meta);\n};\nvar getStyles = function getStyles(options) {\n  var styles = options.styles;\n  if (typeof styles !== 'function') {\n    return styles;\n  }\n  process.env.NODE_ENV !== \"production\" ? warning(styles.length !== 0, \"[JSS] <\" + (options.name || 'Hook') + \" />'s styles function doesn't rely on the \\\"theme\\\" argument. We recommend declaring styles as an object instead.\") : void 0;\n  return styles(options.theme);\n};\nfunction getSheetOptions(options, link) {\n  var minify;\n  if (options.context.id && options.context.id.minify != null) {\n    minify = options.context.id.minify;\n  }\n  var classNamePrefix = options.context.classNamePrefix || '';\n  if (options.name && !minify) {\n    classNamePrefix += options.name.replace(/\\s/g, '-') + \"-\";\n  }\n  var meta = '';\n  if (options.name) meta = options.name + \", \";\n  meta += typeof options.styles === 'function' ? 'Themed' : 'Unthemed';\n  return _extends({}, options.sheetOptions, {\n    index: options.index,\n    meta: meta,\n    classNamePrefix: classNamePrefix,\n    link: link,\n    generateId: options.sheetOptions && options.sheetOptions.generateId ? options.sheetOptions.generateId : options.context.generateId\n  });\n}\nvar createStyleSheet = function createStyleSheet(options) {\n  if (options.context.disableStylesGeneration) {\n    return undefined;\n  }\n  var manager = getManager(options.context, options.index);\n  var existingSheet = manager.get(options.theme);\n  if (existingSheet) {\n    return existingSheet;\n  }\n  var jss = options.context.jss || defaultJss;\n  var styles = getStyles(options);\n  var dynamicStyles = getDynamicStyles(styles);\n  var sheet = jss.createStyleSheet(styles, getSheetOptions(options, dynamicStyles !== null));\n  addMeta(sheet, {\n    dynamicStyles: dynamicStyles,\n    styles: styles\n  });\n  manager.add(options.theme, sheet);\n  return sheet;\n};\nvar removeDynamicRules = function removeDynamicRules(sheet, rules) {\n  // Loop over each dynamic rule and remove the dynamic rule\n  // We can't just remove the whole sheet as this has all of the rules for every component instance\n  for (var key in rules) {\n    sheet.deleteRule(rules[key]);\n  }\n};\nvar updateDynamicRules = function updateDynamicRules(data, sheet, rules) {\n  // Loop over each dynamic rule and update it\n  // We can't just update the whole sheet as this has all of the rules for every component instance\n  for (var key in rules) {\n    sheet.updateOne(rules[key], data);\n  }\n};\nvar addDynamicRules = function addDynamicRules(sheet, data) {\n  var meta = getMeta(sheet);\n  if (!meta) {\n    return undefined;\n  }\n  var rules = {}; // Loop over each dynamic rule and add it to the stylesheet\n\n  for (var key in meta.dynamicStyles) {\n    var initialRuleCount = sheet.rules.index.length;\n    var originalRule = sheet.addRule(key, meta.dynamicStyles[key]); // Loop through all created rules, fixes updating dynamic rules\n\n    for (var i = initialRuleCount; i < sheet.rules.index.length; i++) {\n      var rule = sheet.rules.index[i];\n      sheet.updateOne(rule, data); // If it's the original rule, we need to add it by the correct key so the hook and hoc\n      // can correctly concat the dynamic class with the static one\n\n      rules[originalRule === rule ? key : rule.key] = rule;\n    }\n  }\n  return rules;\n};\nvar getSheetClasses = function getSheetClasses(sheet, dynamicRules) {\n  if (!dynamicRules) {\n    return sheet.classes;\n  }\n  var meta = getMeta(sheet);\n  if (!meta) {\n    return sheet.classes;\n  }\n  var classes = {};\n  for (var key in meta.styles) {\n    classes[key] = sheet.classes[key];\n    if (key in dynamicRules) {\n      classes[key] += \" \" + sheet.classes[dynamicRules[key].key];\n    }\n  }\n  return classes;\n};\nfunction getUseInsertionEffect(isSSR) {\n  return isSSR ? useEffect : React.useInsertionEffect ||\n  // React 18+ (https://github.com/reactwg/react-18/discussions/110)\n  useLayoutEffect;\n}\nvar noTheme = {};\nvar createUseStyles = function createUseStyles(styles, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    _options$index = _options.index,\n    index = _options$index === void 0 ? getSheetIndex() : _options$index,\n    theming = _options.theming,\n    name = _options.name,\n    sheetOptions = _objectWithoutPropertiesLoose(_options, [\"index\", \"theming\", \"name\"]);\n  var ThemeContext$1 = theming && theming.context || ThemeContext;\n  var useTheme = function useTheme(theme) {\n    if (typeof styles === 'function') {\n      return theme || useContext(ThemeContext$1) || noTheme;\n    }\n    return noTheme;\n  };\n  var emptyObject = {};\n  return function useStyles(data) {\n    var isFirstMount = useRef(true);\n    var context = useContext(JssContext);\n    var theme = useTheme(data && data.theme);\n    var _useMemo = useMemo(function () {\n        var newSheet = createStyleSheet({\n          context: context,\n          styles: styles,\n          name: name,\n          theme: theme,\n          index: index,\n          sheetOptions: sheetOptions\n        });\n        if (newSheet && context.isSSR) {\n          // manage immediately during SSRs. browsers will manage the sheet through useInsertionEffect below\n          manageSheet({\n            index: index,\n            context: context,\n            sheet: newSheet,\n            theme: theme\n          });\n        }\n        return [newSheet, newSheet ? addDynamicRules(newSheet, data) : null];\n      }, [context, theme]),\n      sheet = _useMemo[0],\n      dynamicRules = _useMemo[1];\n    getUseInsertionEffect(context.isSSR)(function () {\n      // We only need to update the rules on a subsequent update and not in the first mount\n      if (sheet && dynamicRules && !isFirstMount.current) {\n        updateDynamicRules(data, sheet, dynamicRules);\n      }\n    }, [data]);\n    getUseInsertionEffect(context.isSSR)(function () {\n      if (sheet) {\n        manageSheet({\n          index: index,\n          context: context,\n          sheet: sheet,\n          theme: theme\n        });\n      }\n      return function () {\n        if (sheet) {\n          unmanageSheet({\n            index: index,\n            context: context,\n            sheet: sheet,\n            theme: theme\n          }); // when sheet changes, remove related dynamic rules\n\n          if (dynamicRules) {\n            removeDynamicRules(sheet, dynamicRules);\n          }\n        }\n      };\n    }, [sheet]);\n    var classes = useMemo(function () {\n      return sheet && dynamicRules ? getSheetClasses(sheet, dynamicRules) : emptyObject;\n    }, [sheet, dynamicRules]);\n    useDebugValue(classes);\n    useDebugValue(theme === noTheme ? 'No theme' : theme);\n    useEffect(function () {\n      isFirstMount.current = false;\n    });\n    return classes;\n  };\n};\nvar NoRenderer = function NoRenderer(props) {\n  return props.children || null;\n};\n/**\n * HOC creator function that wrapps the user component.\n *\n * `withStyles(styles, [options])(Component)`\n */\n\nvar createWithStyles = function createWithStyles(styles, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    _options$index = _options.index,\n    index = _options$index === void 0 ? getSheetIndex() : _options$index,\n    theming = _options.theming,\n    injectTheme = _options.injectTheme,\n    sheetOptions = _objectWithoutPropertiesLoose(_options, [\"index\", \"theming\", \"injectTheme\"]);\n  var ThemeContext$1 = theming ? theming.context : ThemeContext;\n  return function (InnerComponent) {\n    if (InnerComponent === void 0) {\n      InnerComponent = NoRenderer;\n    }\n    var displayName = getDisplayName(InnerComponent);\n    var mergeClassesProp = memoize(function (sheetClasses, classesProp) {\n      return classesProp ? mergeClasses(sheetClasses, classesProp) : sheetClasses;\n    });\n    var hookOptions = Object.assign(sheetOptions, {\n      theming: theming,\n      index: index,\n      name: displayName\n    });\n    var useStyles = createUseStyles(styles, hookOptions);\n    var WithStyles = forwardRef(function (props, ref) {\n      var theme = useContext(ThemeContext$1);\n      var newProps = _extends({}, props);\n      if (injectTheme && newProps.theme == null) {\n        newProps.theme = theme;\n      }\n      var sheetClasses = useStyles(newProps);\n      var classes = mergeClassesProp(sheetClasses, props.classes);\n      return createElement(InnerComponent, _extends({}, newProps, {\n        classes: classes,\n        ref: ref\n      }));\n    });\n    WithStyles.displayName = \"WithStyles(\" + displayName + \")\";\n    WithStyles.defaultProps = _extends({}, InnerComponent.defaultProps);\n    WithStyles.InnerComponent = InnerComponent;\n    return hoistNonReactStatics(WithStyles, InnerComponent);\n  };\n};\nvar initialContext = {};\nfunction JssProvider(props) {\n  var managersRef = useRef({});\n  var prevContextRef = useRef();\n  var registryRef = useRef(null);\n  var createContext = function createContext(parentContext, prevContext) {\n    if (prevContext === void 0) {\n      prevContext = initialContext;\n    }\n    var registry = props.registry,\n      classNamePrefix = props.classNamePrefix,\n      jss = props.jss,\n      generateId = props.generateId,\n      disableStylesGeneration = props.disableStylesGeneration,\n      media = props.media,\n      id = props.id,\n      isSSR = props.isSSR;\n    var context = _extends({}, parentContext);\n    if (registry) {\n      context.registry = registry; // This way we identify a new request on the server, because user will create\n      // a new Registry instance for each.\n\n      if (registry !== registryRef.current) {\n        // We reset managers because we have to regenerate all sheets for the new request.\n        managersRef.current = {};\n        registryRef.current = registry;\n      }\n    }\n    context.managers = managersRef.current;\n    if (id !== undefined) {\n      context.id = id;\n    }\n    if (generateId !== undefined) {\n      context.generateId = generateId;\n    } else if (!context.generateId || !prevContext || context.id !== prevContext.id) {\n      context.generateId = createGenerateId(context.id);\n    }\n    if (classNamePrefix) {\n      context.classNamePrefix = (context.classNamePrefix || '') + classNamePrefix;\n    }\n    if (media !== undefined) {\n      context.media = media;\n    }\n    if (jss) {\n      context.jss = jss;\n    }\n    if (disableStylesGeneration !== undefined) {\n      context.disableStylesGeneration = disableStylesGeneration;\n    }\n    if (isSSR !== undefined) {\n      context.isSSR = isSSR;\n    }\n    if (prevContext && shallowEqualObjects(prevContext, context)) {\n      return prevContext;\n    }\n    return context;\n  };\n  var renderProvider = function renderProvider(parentContext) {\n    var children = props.children;\n    var context = createContext(parentContext, prevContextRef.current);\n    prevContextRef.current = context;\n    return createElement(JssContext.Provider, {\n      value: context\n    }, children);\n  };\n  return createElement(JssContext.Consumer, null, renderProvider);\n}\nvar parseStyles = function parseStyles(args) {\n  var dynamicStyles = [];\n  var staticStyle;\n  var labels = []; // Not using ...rest to optimize perf.\n\n  for (var key in args) {\n    var style = args[key];\n    if (!style) continue;\n    if (typeof style === 'function') {\n      dynamicStyles.push(style);\n    } else {\n      if (!staticStyle) staticStyle = {};\n      Object.assign(staticStyle, style);\n      var _staticStyle = staticStyle,\n        _label = _staticStyle.label;\n      if (_label) {\n        if (labels.indexOf(_label) === -1) labels.push(_label);\n      }\n    }\n  }\n  var styles = {};\n  var label = labels.length === 0 ? 'sc' : labels.join('-');\n  if (staticStyle) {\n    // Label should not leak to the core.\n    if ('label' in staticStyle) delete staticStyle.label;\n    styles[label] = staticStyle;\n  } // When there is only one function rule, we don't need to wrap it.\n\n  if (dynamicStyles.length === 1) {\n    styles.scd = dynamicStyles[0];\n  } // We create a new function rule which will call all other function rules\n  // and merge the styles they return.\n\n  if (dynamicStyles.length > 1) {\n    styles.scd = function (props) {\n      var merged = {};\n      for (var i = 0; i < dynamicStyles.length; i++) {\n        var dynamicStyle = dynamicStyles[i](props);\n        if (dynamicStyle) Object.assign(merged, dynamicStyle);\n      }\n      return merged;\n    };\n  }\n  return {\n    styles: styles,\n    label: label\n  };\n};\nvar shouldForwardPropSymbol = Symbol('react-jss-styled');\nvar getShouldForwardProp = function getShouldForwardProp(tagOrComponent, options) {\n  var shouldForwardProp = options.shouldForwardProp;\n  var childShouldForwardProp = tagOrComponent[shouldForwardPropSymbol];\n  var finalShouldForwardProp = shouldForwardProp || childShouldForwardProp;\n  if (shouldForwardProp && childShouldForwardProp) {\n    finalShouldForwardProp = function finalShouldForwardProp(prop) {\n      return childShouldForwardProp(prop) && shouldForwardProp(prop);\n    };\n  }\n  return finalShouldForwardProp;\n};\nvar getChildProps = function getChildProps(props, shouldForwardProp, isTag) {\n  var childProps = {};\n  for (var prop in props) {\n    if (shouldForwardProp) {\n      if (shouldForwardProp(prop) === true) {\n        childProps[prop] = props[prop];\n      }\n      continue;\n    } // We don't want to pass non-dom props to the DOM.\n\n    if (isTag) {\n      if (isPropValid(prop)) {\n        childProps[prop] = props[prop];\n      }\n      continue;\n    }\n    childProps[prop] = props[prop];\n  }\n  return childProps;\n}; // eslint-disable-next-line no-unused-vars\n\nvar configureStyled = function configureStyled(tagOrComponent, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _options = options,\n    theming = _options.theming;\n  var isTag = typeof tagOrComponent === 'string';\n  var ThemeContext$1 = theming ? theming.context : ThemeContext;\n  var shouldForwardProp = getShouldForwardProp(tagOrComponent, options);\n  var _options2 = options,\n    _ = _options2.shouldForwardProp,\n    hookOptions = _objectWithoutPropertiesLoose(_options2, [\"shouldForwardProp\"]);\n  return function createStyledComponent() {\n    // eslint-disable-next-line prefer-rest-params\n    var _parseStyles = parseStyles(arguments),\n      styles = _parseStyles.styles,\n      label = _parseStyles.label;\n    var useStyles = createUseStyles(styles, hookOptions);\n    var Styled = function Styled(props) {\n      var as = props.as,\n        className = props.className;\n      var theme = useContext(ThemeContext$1);\n      var propsWithTheme = Object.assign({\n        theme: theme\n      }, props);\n      var classes = useStyles(propsWithTheme);\n      var childProps = getChildProps(props, shouldForwardProp, isTag);\n      var classNames = ((classes[label] || classes.sc || '') + \" \" + (classes.scd || '')).trim();\n      childProps.className = className ? className + \" \" + classNames : classNames;\n      if (!isTag && shouldForwardProp) {\n        tagOrComponent[shouldForwardPropSymbol] = shouldForwardProp;\n      }\n      if (isTag && as) {\n        return createElement(as, childProps);\n      }\n      return createElement(tagOrComponent, childProps);\n    };\n    return Styled;\n  };\n};\n\n/* eslint-disable prefer-rest-params, prefer-spread */\nvar create = function create(css) {\n  if (css === void 0) {\n    css = defaultCss;\n  }\n  return function createElement$1(type, props) {\n    var args = arguments;\n    if (props && props.css) {\n      var className = css(props.css);\n      var newProps = Object.assign({}, props);\n      newProps.className = props.className ? props.className + \" \" + className : className;\n      delete newProps.css;\n      args[1] = newProps;\n    }\n    return createElement.apply(undefined, args);\n  };\n};\nvar jsx = create();\nexport default createWithStyles;\nexport { JssContext, JssProvider, create as createJsx, createUseStyles, defaultJss as jss, jsx, configureStyled as styled, createWithStyles as withStyles };","map":null,"metadata":{},"sourceType":"module"}